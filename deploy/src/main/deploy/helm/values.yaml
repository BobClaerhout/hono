# Default values for eclipse-hono.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# amqpMessagingNetworkDeployExample indicates whether the example AMQP Messaging Network
# consisting of a single Dispatch Router and Artemis broker should be
# deployed and used.
amqpMessagingNetworkDeployExample: true
amqpMessagingNetworkSpec: {}
commandAndControlSpec: {}

# deviceRegistryDeployExample indicates whether the example Device Registry
# should be deployed and used.
deviceRegistryDeployExample: true
tenantSpec: {}
deviceRegistrationSpec: {}
credentialsSpec: {}
deviceConnectionSpec: {}

# dispatchRouterImageName contains the name (including tag)
# of the container image to use for the example AQMP Messaging Network
dispatchRouterImageName: ${dispatch-router.image.name}

# artemisImageName contains the name (including tag) of the container
# image to use for the example AMQP Messaging network
artemisImageName: ${artemis.image.name}

# honoContainerRegistry contains the host name of the container registry
# to pull Hono images from.
# This can be set to e.g. a private container registry where
# snapshot images have been pushed to.
# By default we pull from Docker Hub.
honoContainerRegistry: index.docker.io

# honoImageTag contains the image tag to use when pulling Hono container images.
# The default value is the chart's app version. It may be overridden in
# order to pull custom built images from a (private) container registry.
honoImageTag: ${project.version}

# defaultJavaOptions contains options to pass to the JVM when starting
# up Hono's containers
defaultJavaOptions: ${default-java-options}

# the port that the Hono components' Prometheus scraping endpoint is exposed on
monitoring:
  prometheus:
    port: ${prometheus.scraping.port}

# healthCheckPort is the port that the Hono components bind their health check
# server to.
healthCheckPort: ${vertx.health.port}

# platform indicates the type of container orchestration platform we are deploying to.
# Supported values are:
# - openshift
# - kubernetes
#
# When setting to "openshift", Route resources will also be deployed.
platform: kubernetes

# useLoadBalancer indicates whether services should be deployed using the
# "LoadBalancer" type (true) or the "NodePort" type (false).
# This property will be ignored when deploying to platform "openshift".
useLoadBalancer: true

prometheus:
  # createInstance indicates whether a Prometheus server should be created
  # using the Prometheus chart.
  # Set this property to false if you want to use an already existing server
  # instead. In that case, set the "name" and "port" properties to the
  # existing server's host name and port.
  createInstance: true
  # host contains the host name of an existing Prometheus server.
  # This property is used to configure a corresponding datasource in Grafana
  # if createInstance is set to false.
  #host:
  # post contains the port number of an existing Prometheus server.
  # This property is used to configure a corresponding datasource in Grafana
  # if createInstance is set to false.
  #port: 9090

  ## Define serviceAccount names for components. Defaults to component's fully qualified name.
  ##
  serviceAccounts:
    alertmanager:
      create: false
      name:
    kubeStateMetrics:
      create: false
      name:
    nodeExporter:
      create: false
      name:
    pushgateway:
      create: false
      name:
    server:
      create: true
      name:

  server:
    configMapOverrideName: prometheus-config
    global:
      scrape_interval: 10s
    service:
      servicePort: 9090

  alertmanager:
    enabled: false

  kubeStateMetrics:
    enabled: false

  nodeExporter:
    enabled: false

  pushgateway:
    enabled: false

grafana:
  enabled: true
  adminPassword: admin
  ## Expose the grafana service to be accessed from outside the cluster (LoadBalancer service).
  ## or access it from within the cluster (ClusterIP service). Set the service type and the port to serve it.
  ## ref: http://kubernetes.io/docs/user-guide/services/
  ##
  service:
    type: ClusterIP
    port: 3000
    targetPort: 3000
    annotations: {}
    labels:
      app.kubernetes.io/name: eclipse-hono
      app.kubernetes.io/component: dashboard

  ## Sidecars that collect the configmaps with specified label and stores the included files them into the respective folders
  ## Requires at least Grafana 5 to work and can't be used together with parameters dashboardProviders, datasources and dashboards
  sidecar:
    dashboards:
      enabled: true
      # label that the configmaps with dashboards are marked with
      label: grafana_dashboard
    datasources:
      enabled: true
      # label that the configmaps with datasources are marked with
      label: grafana_datasource

  rbac:
    namespaced: true

# jaeger contains properties for configuring the Jaeger tracing system that is used
# by Hono's components to trace the distributed processing of messages.
jaeger:
  # whether the Jaeger tracing component should be deployed
  enabled: false
  agentHost: jaeger-agent
  # environment variables for containers that provide tracing data
  env:
    JAEGER_AGENT_HOST: jaeger-agent
    JAEGER_AGENT_PORT: "6831"
    JAEGER_SAMPLER_TYPE: const
    JAEGER_SAMPLER_PARAM: 1
  deploy:
    # configuration of Jaeger deployment
    # see examples of spec definitions here: https://github.com/jaegertracing/jaeger-operator/tree/master/deploy/examples
    spec:
      strategy: allInOne
      storage:
        options:
          memory:
            max-traces: 100000
